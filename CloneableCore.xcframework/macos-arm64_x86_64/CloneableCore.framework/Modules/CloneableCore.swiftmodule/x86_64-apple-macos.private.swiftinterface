// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target x86_64-apple-macos14.0 -enable-objc-interop -cxx-interoperability-mode=default -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name CloneableCore
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Alamofire
import AnyCodable
import Cloneable_Swift_Client
import Foundation
import JXKit
import SQLite
import Swift
import SystemConfiguration
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import cxxLibrary
import os
extension XML {
  @dynamicMemberLookup public enum Accessor : Swift.CustomStringConvertible, Swift.Sequence {
    case singleElement(XML.Element)
    case sequence([XML.Element])
    case failure(any Swift.Error)
    public init(_ element: XML.Element)
    public init(_ sequence: [XML.Element])
    public init(_ error: any Swift.Error)
    public subscript(dynamicMember member: Swift.String) -> XML.Accessor {
      get
    }
    public subscript(path: Swift.Array<any XMLSubscriptType>) -> XML.Accessor {
      get
    }
    public subscript(path: any XMLSubscriptType...) -> XML.Accessor {
      get
    }
    public var name: Swift.String? {
      get
    }
    public var text: Swift.String? {
      get
      set
    }
    public var bool: Swift.Bool? {
      get
    }
    public var url: Foundation.URL? {
      get
    }
    public var int: Swift.Int? {
      get
    }
    public var double: Swift.Double? {
      get
    }
    public var attributes: [Swift.String : Swift.String] {
      get
      set
    }
    public var all: [XML.Element]? {
      get
    }
    public var names: [Swift.String]? {
      get
    }
    public var error: (any Swift.Error)? {
      get
    }
    public var element: XML.Element? {
      get
    }
    public var last: XML.Accessor {
      get
    }
    public var first: XML.Accessor {
      get
    }
    public func map<T>(_ transform: (XML.Accessor) -> T) -> [T]
    @available(*, renamed: "flatMap")
    public func mapWithSqueezeNil<T>(_ transform: (XML.Accessor) -> T?) -> [T]
    public func append(_ newElement: XML.Element)
    public func makeIterator() -> Swift.AnyIterator<XML.Accessor>
    public var description: Swift.String {
      get
    }
    public typealias Element = XML.Accessor
    public typealias Iterator = Swift.AnyIterator<XML.Accessor>
  }
}
extension XML {
  public class Converter {
    public init(_ accessor: XML.Accessor)
    public func makeDocument(withDeclaration: Swift.Bool = true) throws -> Swift.String
    @objc deinit
  }
}
extension XML {
  open class Element {
    open var name: Swift.String
    open var text: Swift.String?
    open var attributes: [Swift.String : Swift.String]
    open var childElements: [XML.Element]
    open var lineNumberStart: Swift.Int
    open var lineNumberEnd: Swift.Int
    open var CDATA: Foundation.Data?
    open var ignoreNamespaces: Swift.Bool
    weak open var parentElement: XML.Element?
    public init(name: Swift.String, text: Swift.String? = nil, attributes: [Swift.String : Swift.String] = [:], childElements: [XML.Element] = [], lineNumberStart: Swift.Int = -1, lineNumberEnd: Swift.Int = -1, CDATA: Foundation.Data? = nil, ignoreNamespaces: Swift.Bool = false)
    @objc deinit
  }
}
public enum XMLError : Swift.Error {
  case failToEncodeString
  case interruptedParseError(rawError: any Swift.Error)
  case accessError(description: Swift.String)
}
public protocol XMLSubscriptType {
}
extension Swift.Int : XMLSubscriptType {
}
extension Swift.String : XMLSubscriptType {
}
infix operator ?= : DefaultPrecedence
public func ?= <T>(lhs: inout T, rhs: T?)
infix operator ?<< : DefaultPrecedence
public func ?<< <T>(lhs: inout [T], rhs: T?)
@_hasMissingDesignatedInitializers open class XML {
  open class func parse(_ data: Foundation.Data, trimming manner: Foundation.CharacterSet? = nil, ignoreNamespaces: Swift.Bool = false) -> XML.Accessor
  open class func parse(_ str: Swift.String, trimming manner: Foundation.CharacterSet? = nil, ignoreNamespaces: Swift.Bool = false) throws -> XML.Accessor
  open class func document(_ accessor: XML.Accessor, withDeclaration: Swift.Bool = true) throws -> Swift.String
  @objc deinit
}
public protocol XMLAttributeDeserializable {
  static func deserialize(_ attribute: XMLAttribute) throws -> Self
  func validate() throws
}
extension XMLAttributeDeserializable {
  public static func deserialize(attribute: XMLAttribute) throws -> Self
  public func validate() throws
}
public protocol XMLElementDeserializable {
  static func deserialize(_ element: XMLElement) throws -> Self
  func validate() throws
}
extension XMLElementDeserializable {
  public static func deserialize(_ element: XMLElement) throws -> Self
  public func validate() throws
}
extension XMLIndexer {
  public func value<T>(ofAttribute attr: Swift.String) throws -> T where T : XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) -> T? where T : XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T] where T : XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T]? where T : XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T?] where T : XMLAttributeDeserializable
  public func value<T>() throws -> T where T : XMLElementDeserializable
  public func value<T>() throws -> T? where T : XMLElementDeserializable
  public func value<T>() throws -> [T] where T : XMLElementDeserializable
  public func value<T>() throws -> [T]? where T : XMLElementDeserializable
  public func value<T>() throws -> [T?] where T : XMLElementDeserializable
  public func value<T>() throws -> T where T : XMLObjectDeserialization
  public func value<T>() throws -> T? where T : XMLObjectDeserialization
  public func value<T>() throws -> [T] where T : XMLObjectDeserialization
  public func value<T>() throws -> [T]? where T : XMLObjectDeserialization
  public func value<T>() throws -> [T?] where T : XMLObjectDeserialization
}
extension XMLIndexer {
  public func value<T, A>(ofAttribute attr: A) throws -> T where T : XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
  public func value<T, A>(ofAttribute attr: A) -> T? where T : XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
  public func value<T, A>(ofAttribute attr: A) throws -> [T] where T : XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
  public func value<T, A>(ofAttribute attr: A) throws -> [T]? where T : XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
  public func value<T, A>(ofAttribute attr: A) throws -> [T?] where T : XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
}
extension XMLElement {
  public func value<T>(ofAttribute attr: Swift.String) throws -> T where T : XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) -> T? where T : XMLAttributeDeserializable
}
extension XMLElement {
  public func value<T, A>(ofAttribute attr: A) throws -> T where T : XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
  public func value<T, A>(ofAttribute attr: A) -> T? where T : XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
}
public protocol XMLObjectDeserialization {
  static func deserialize(_ element: XMLIndexer) throws -> Self
  func validate() throws
}
extension XMLObjectDeserialization {
  public static func deserialize(_ element: XMLIndexer) throws -> Self
  public func validate() throws
}
public protocol XMLValueDeserialization : XMLAttributeDeserializable, XMLElementDeserializable {
  static func deserialize(_ element: XMLElement) throws -> Self
  static func deserialize(_ attribute: XMLAttribute) throws -> Self
  func validate() throws
}
extension XMLValueDeserialization {
  public static func deserialize(_ element: XMLElement) throws -> Self
  public static func deserialize(attribute: XMLAttribute) throws -> Self
  public func validate() throws
}
extension Swift.Bool : XMLValueDeserialization {
  public static func deserialize(_ element: XMLElement) throws -> Swift.Bool
  public static func deserialize(_ attribute: XMLAttribute) throws -> Swift.Bool
  public func validate()
}
extension Swift.Double : XMLValueDeserialization {
  public static func deserialize(_ element: XMLElement) throws -> Swift.Double
  public static func deserialize(_ attribute: XMLAttribute) throws -> Swift.Double
  public func validate()
}
extension Swift.Float : XMLValueDeserialization {
  public static func deserialize(_ element: XMLElement) throws -> Swift.Float
  public static func deserialize(_ attribute: XMLAttribute) throws -> Swift.Float
  public func validate()
}
extension Swift.Int : XMLValueDeserialization {
  public static func deserialize(_ element: XMLElement) throws -> Swift.Int
  public static func deserialize(_ attribute: XMLAttribute) throws -> Swift.Int
  public func validate()
}
extension Swift.String : XMLValueDeserialization {
  public static func deserialize(_ element: XMLElement) -> Swift.String
  public static func deserialize(_ attribute: XMLAttribute) -> Swift.String
  public func validate()
}
public enum IndexingError : Swift.Error {
  case attribute(attr: Swift.String)
  case attributeValue(attr: Swift.String, value: Swift.String)
  case key(key: Swift.String)
  case index(idx: Swift.Int)
  case initialize(instance: Swift.AnyObject)
  case encoding
  case error
  @available(*, unavailable, renamed: "attribute(attr:)")
  public static func Attribute(attr: Swift.String) -> IndexingError
  @available(*, unavailable, renamed: "attributeValue(attr:value:)")
  public static func AttributeValue(attr: Swift.String, value: Swift.String) -> IndexingError
  @available(*, unavailable, renamed: "key(key:)")
  public static func Key(key: Swift.String) -> IndexingError
  @available(*, unavailable, renamed: "index(idx:)")
  public static func Index(idx: Swift.Int) -> IndexingError
  @available(*, unavailable, renamed: "initialize(instance:)")
  public static func Init(instance: Swift.AnyObject) -> IndexingError
  @available(*, unavailable, renamed: "error")
  public static var Error: IndexingError {
    get
  }
}
extension IndexingError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension IndexingError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct ParsingError : Swift.Error {
  public let line: Swift.Int
  public let column: Swift.Int
}
extension ParsingError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension ParsingError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum XMLDeserializationError : Swift.Error {
  case implementationIsMissing(method: Swift.String)
  case nodeIsInvalid(node: Swift.String)
  case nodeHasNoValue
  case typeConversionFailed(type: Swift.String, element: XMLElement)
  case attributeDoesNotExist(element: XMLElement, attribute: Swift.String)
  case attributeDeserializationFailed(type: Swift.String, attribute: XMLAttribute)
  @available(*, unavailable, renamed: "implementationIsMissing(method:)")
  public static func ImplementationIsMissing(method: Swift.String) -> XMLDeserializationError
  @available(*, unavailable, renamed: "nodeHasNoValue(_:)")
  public static func NodeHasNoValue(_: IndexOps) -> XMLDeserializationError
  @available(*, unavailable, renamed: "typeConversionFailed(_:)")
  public static func TypeConversionFailed(_: IndexingError) -> XMLDeserializationError
  @available(*, unavailable, renamed: "attributeDoesNotExist(_:_:)")
  public static func AttributeDoesNotExist(_ attr: Swift.String, _ value: Swift.String) throws -> XMLDeserializationError
  @available(*, unavailable, renamed: "attributeDeserializationFailed(_:_:)")
  public static func AttributeDeserializationFailed(_ attr: Swift.String, _ value: Swift.String) throws -> XMLDeserializationError
}
extension XMLDeserializationError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension XMLDeserializationError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class IndexOp {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IndexOps {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class TextElement : XMLContent {
  final public let text: Swift.String
  @objc deinit
}
extension TextElement : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct XMLAttribute {
  public let name: Swift.String
  public let text: Swift.String
}
extension XMLAttribute : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol XMLContent : Swift.CustomStringConvertible {
}
@_hasMissingDesignatedInitializers public class XMLElement : XMLContent {
  final public let name: Swift.String
  public var caseInsensitive: Swift.Bool {
    get
  }
  public var allAttributes: [Swift.String : XMLAttribute]
  public func attribute(by name: Swift.String) -> XMLAttribute?
  public var text: Swift.String {
    get
  }
  public var recursiveText: Swift.String {
    get
  }
  public var innerXML: Swift.String {
    get
  }
  public var children: [any XMLContent]
  @objc deinit
}
extension XMLElement : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension XMLElement {
  public func attribute<N>(by name: N) -> XMLAttribute? where N : Swift.RawRepresentable, N.RawValue == Swift.String
}
extension XMLHash {
  public typealias XMLElement = XMLHashXMLElement
}
public typealias XMLHashXMLElement = XMLElement
extension XMLIndexer {
  public func findInnerChild(_ elemName: Swift.String) -> XMLIndexer?
  public func findAllInnerChildren(_ elemName: Swift.String) -> [XMLIndexer]
}
@_hasMissingDesignatedInitializers public class XMLHash {
  public class func config(_ configAction: (XMLHashOptions) -> Swift.Void) -> XMLHash
  public func parse(_ xml: Swift.String) -> XMLIndexer
  public func parse(_ data: Foundation.Data) -> XMLIndexer
  public class func parse(_ xml: Swift.String) -> XMLIndexer
  public class func parse(_ data: Foundation.Data) -> XMLIndexer
  public class func lazy(_ xml: Swift.String) -> XMLIndexer
  public class func lazy(_ data: Foundation.Data) -> XMLIndexer
  @objc deinit
}
@_hasMissingDesignatedInitializers public class XMLHashOptions {
  public var shouldProcessLazily: Swift.Bool
  public var shouldProcessNamespaces: Swift.Bool
  public var caseInsensitive: Swift.Bool
  public var encoding: Swift.String.Encoding
  public var userInfo: [Swift.CodingUserInfoKey : Any]
  public var detectParsingErrors: Swift.Bool
  @objc deinit
}
public enum XMLIndexer {
  case element(XMLElement)
  case list([XMLElement])
  case stream(IndexOps)
  case xmlError(IndexingError)
  case parsingError(ParsingError)
  @available(*, unavailable, renamed: "element(_:)")
  public static func Element(_: XMLElement) -> XMLIndexer
  @available(*, unavailable, renamed: "list(_:)")
  public static func List(_: [XMLElement]) -> XMLIndexer
  @available(*, unavailable, renamed: "stream(_:)")
  public static func Stream(_: IndexOps) -> XMLIndexer
  @available(*, unavailable, renamed: "xmlError(_:)")
  public static func XMLError(_: IndexingError) -> XMLIndexer
  @available(*, unavailable, renamed: "withAttribute(_:_:)")
  public static func withAttr(_ attr: Swift.String, _ value: Swift.String) throws -> XMLIndexer
  public var element: XMLElement? {
    get
  }
  public var all: [XMLIndexer] {
    get
  }
  public var children: [XMLIndexer] {
    get
  }
  @available(*, unavailable, renamed: "filterChildren(_:)")
  public func filter(_ included: (_ elem: XMLElement, _ index: Swift.Int) -> Swift.Bool) -> XMLIndexer
  public func filterChildren(_ included: (_ elem: XMLElement, _ index: Swift.Int) -> Swift.Bool) -> XMLIndexer
  public func filterAll(_ included: (_ elem: XMLElement, _ index: Swift.Int) -> Swift.Bool) -> XMLIndexer
  public var userInfo: [Swift.CodingUserInfoKey : Any] {
    get
  }
  public func withAttribute(_ attr: Swift.String, _ value: Swift.String) throws -> XMLIndexer
  public init(_ rawObject: Swift.AnyObject) throws
  public init(_ elem: XMLElement)
  public func byKey(_ key: Swift.String) throws -> XMLIndexer
  public subscript(key: Swift.String) -> XMLIndexer {
    get
  }
  public func byIndex(_ index: Swift.Int) throws -> XMLIndexer
  public subscript(index: Swift.Int) -> XMLIndexer {
    get
  }
}
extension XMLIndexer : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension XMLIndexer {
  public func withAttribute<A, V>(_ attr: A, _ value: V) throws -> XMLIndexer where A : Swift.RawRepresentable, V : Swift.RawRepresentable, A.RawValue == Swift.String, V.RawValue == Swift.String
  public func byKey<K>(_ key: K) throws -> XMLIndexer where K : Swift.RawRepresentable, K.RawValue == Swift.String
  public subscript<K>(key: K) -> XMLIndexer where K : Swift.RawRepresentable, K.RawValue == Swift.String {
    get
  }
}
public class CloneableCore {
  public var appID: Swift.String
  public var connection_state: CloneableConnectionState {
    get
    set
  }
  public var auth_status: CloneableAuthStatus {
    get
    set
  }
  public var sync_status: CloneableSyncStatus {
    get
    set
  }
  public init(runtime_environment: RUNTIME_ENVIRONMENT = .mobile) throws
  #if compiler(>=5.3) && $AsyncAwait
  public func login(credentials: CloneableCredentials) async throws
  #endif
  public func signOut()
  @objc deinit
  public func getDataCache() -> DataManager
  #if compiler(>=5.3) && $AsyncAwait
  public func startSyncEngine() async throws
  #endif
  public func subscribeToNetworkUpdates(_ observer: @escaping (CloneableConnectionState) -> Swift.Void) -> NetworkMonitor.NetworkStatusToken
  public func subscribeToSyncStatusUpdates(_ observer: @escaping (CloneableSyncStatus) -> Swift.Void) -> SyncStatusToken
  public func subscribeToDeployedWorkflowSyncUpdates(_ observer: @escaping (SyncManagerDeployedWorkflowChangeType) -> Swift.Void) -> CloneableObserverToken?
  public func getConnectionStatus() -> CloneableConnectionState
  public func clearCache() throws
  public func cache() -> LocalCacheManager
  public func getRuntimeEnvironment() -> RUNTIME_ENVIRONMENT
  public func startWorkflow(workflow: Cloneable_Swift_Client.DeployedWorkflowSchema, navController: any NavigationCoordinator)
  public func startWorkflow(workflowId: Swift.String)
}
@_hasMissingDesignatedInitializers public class Components {
  public static func addComponent(component: Component)
  @objc deinit
}
public enum CloneableCredentials {
  case auth0(jwt: Swift.String)
  case apiKey(key: Swift.String)
}
extension DataManager {
  #if compiler(>=5.3) && $AsyncAwait
  public func createCompletedWorkflow(completedWorkflow: Cloneable_Swift_Client.CompletedWorkflowSchema) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func updateCompletedWorkflow(completedWorkflow: Cloneable_Swift_Client.CompletedWorkflowSchema) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func deleteCompletedWorkflow(id: Foundation.UUID) async throws
  #endif
}
extension DataManager {
  #if compiler(>=5.3) && $AsyncAwait
  public func insertDataObject(_ DataObjectSchema: CloneableObject) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func updateDataObject(_ DataObjectSchema: CloneableObject, userId: Swift.String) async throws
  #endif
}
extension DataManager {
  public func fileExistsInAnyDataField(fileId: Swift.String) -> Swift.Bool
  public func getAllFileIds() -> [Swift.String]
  public func getNumberOfDownloadedDataObjects() throws -> Swift.Int
  public func deleteAllDataObjects() throws
  public func getObjectsOfType(objectID: Swift.String, objectTemplateRevision: Swift.Double, searchString: Swift.String = "") -> [CloneableObject]
  public func getFirstLiveObjectFromFilter(objectTemplateID: Swift.String, fieldFilters: [Swift.String : AnyCloneableData]) -> Cloneable_Swift_Client.DataObjectSchema?
  public func getDataObjectByInstanceId(instanceId: Swift.String) throws -> CloneableObject?
}
extension DataManager {
  public func subscribeToDataObjectChanges(objectInstanceId: Swift.String, callback: @escaping (SyncManagerDataObjectChangeType) -> Swift.Void) -> DataObjectObserverToken
  public func unsubscribeFromDataObjectChanges(token: DataObjectObserverToken)
}
extension DataManager {
  public func getAllWorkflows() throws -> [Cloneable_Swift_Client.DeployedWorkflowSchema]
  public func getWorkflow(workflowId: Swift.String) throws -> Cloneable_Swift_Client.DeployedWorkflowSchema
  public func getAllFileResources() throws -> [Swift.String]
  public func getFileResourcesDict() throws -> [Swift.String : [Swift.String]]
  public func fileExistsInResources(fileId: Swift.String) -> Swift.Bool
}
extension DataManager {
  public func getFileInfo(id: Swift.String) throws -> Cloneable_Swift_Client.FileSchema
  #if compiler(>=5.3) && $AsyncAwait
  public func getFileDownloadURL(fileId: Swift.String) async throws -> Swift.String
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func getFileUploadURL(fileInformation: SyncedFileInformationV2) async throws -> Swift.String
  #endif
}
extension DataManager {
  #if compiler(>=5.3) && $AsyncAwait
  public func createNewFileInformation(file: Cloneable_Swift_Client.FileSchema) async throws -> Swift.String
  #endif
}
extension DataManager {
  #if compiler(>=5.3) && $AsyncAwait
  public func updateFileAsUploaded(fileId: Swift.String) async throws
  #endif
}
extension DataManager {
  #if compiler(>=5.3) && $AsyncAwait
  public func createNotificationRequest(notificationRequest: Cloneable_Swift_Client.NotificationRequestSchema) async throws
  #endif
}
public class DataManager {
  weak public static var ref: DataManager?
  public var file_sync_engine: CloneableFileSyncEngine
  public init(persist_cache: Swift.Bool, appID: Swift.String, isProduction: Swift.Bool = false) throws
  @objc deinit
  public func clearFileCache()
  public func getUserId() -> Swift.String?
  public func getUserData() -> Cloneable_Swift_Client.UserSchema?
  public func canProceed(auth0_jwt: Swift.String) -> Swift.String?
}
public enum ModelToSync : Swift.String, Swift.Codable {
  case FileInformation
  case CompletedWorkflow
  case NotificationRequest
  case DataObject
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum APICallStatus : Swift.String, Swift.Codable {
  case Pending
  case Syncing
  case Synced
  case Error
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FileInformationCallType : Swift.String, APICallType {
  case createFile
  case updateUploadStatus
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CompletedWorkflowCallType : Swift.String, APICallType {
  case startWorkflow
  case updateWorkflow
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum NotificationRequestCallType : Swift.String, APICallType {
  case uploadRequest
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum DataObjectCallType : Swift.String, APICallType {
  case createRequest
  case updateRequest
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol APICallType : Swift.Decodable, Swift.Encodable {
  var rawValue: Swift.String { get }
}
public struct APICall : Swift.Codable {
  public let id: Swift.String
  public let relatedID: Swift.String
  public let modelToSync: ModelToSync
  public var status: APICallStatus
  public let dateCreated: Foundation.Date
  public let callType: any APICallType
  public init(relatedId: Swift.String, modelToSync: ModelToSync, status: APICallStatus, dateCreated: Foundation.Date, callType: any APICallType)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public class DatabaseManager {
  public var connection: SQLite.Connection?
  public init(persist_cache: Swift.Bool) throws
  @objc deinit
}
public enum SyncManagerDeployedWorkflowChangeType {
  case insert(workflow: Cloneable_Swift_Client.DeployedWorkflowSchema)
  case insertMultiple(workflowIds: [Swift.String])
  case delete(workflowId: Swift.String)
  case clearAll
}
@_hasMissingDesignatedInitializers public class SyncedFileDatabase : SQLiteTable {
  public typealias DatabaseChangeHandler = (_ change: SyncedFileDatabase.DatabaseChange) -> Swift.Void
  public var changeHandler: SyncedFileDatabase.DatabaseChangeHandler?
  public func updateSyncStatus(fileId: Foundation.UUID, isComplete: Swift.Bool) throws
  public func updateFileURL(fileId: Foundation.UUID, fileURL: Swift.String) throws
  public func delete(fileId: Foundation.UUID) throws
  public func getSyncedFile(cloneableFileID: Foundation.UUID?) throws -> SyncedFileInformationV2?
  public func getUnsyncedFileCount() -> Swift.Int?
  public func getTotalFileCount() -> Swift.Int?
  public func getSyncedFileCount() -> Swift.Int?
  public func getFirstUnsyncedFile() throws -> SyncedFileInformationV2?
  public func getSyncedFiles() throws -> [SyncedFileInformationV2]
  public func getSyncedFileByFileName(fileName: Swift.String) throws -> SyncedFileInformationV2?
  public func deleteAllSyncedFiles() throws
  public func observeFile(fileId: Foundation.UUID, observer: @escaping SyncedFileDatabase.DatabaseChangeHandler) -> FileObserverToken
  @objc deinit
}
extension SyncedFileDatabase {
  public func setChangeHandler(_ newHandler: SyncedFileDatabase.DatabaseChangeHandler?)
  public enum DatabaseChange {
    case insert(file: SyncedFileInformationV2)
    case update(file: SyncedFileInformationV2)
    case delete(fileId: Foundation.UUID)
  }
  public func notifyChangeHandler(of change: SyncedFileDatabase.DatabaseChange)
}
@_hasMissingDesignatedInitializers public class FileObserverToken {
  public func cancel()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SyncedFileInformationObserverToken {
  public func cancel()
  @objc deinit
}
public class LocalCacheManager {
  public init(persist_cache: Swift.Bool) throws
  @objc deinit
  public func table<T>(ofType type: T.Type) -> T? where T : SQLiteTable
}
extension LocalCacheManager {
  public func clearCache() throws
  public func startCache(persist_cache: Swift.Bool) throws
}
public typealias DataObjectObserverToken = Foundation.UUID
public enum SyncManagerDataObjectChangeType {
  case insert(object: Cloneable_Swift_Client.DataObjectSchema)
  case change(object: Cloneable_Swift_Client.DataObjectSchema)
  case delete(objectId: Swift.String)
  case clearAll
}
extension DataManager {
  public func resetDataObjectCache()
}
extension DataManager {
  public func resetDeployedWorkflowCache()
}
extension DataManager {
  public func resetFileCache()
}
public typealias FileSyncStatusToken = Foundation.UUID
@_hasMissingDesignatedInitializers public class CloneableFileSyncEngine {
  public var syncedFileQueue: Dispatch.DispatchQueue
  public var totalFiles: Swift.Int
  public var filesSynced: Swift.Int
  public func getLiveCloneableFileObject(id: Foundation.UUID) -> Cloneable_Swift_Client.FileSchema?
  public func processAndSyncObjectsNonCompleteRequests()
  public func getCloneableDataFromFile(fileName: Swift.String, fileType: Swift.String, displayName: Swift.String) -> AnyCloneableData?
  public func fileExistsLocally(fileName: Swift.String) -> Swift.Bool
  public func fileExistsLocally(fileURL: Foundation.URL) -> Swift.Bool
  public func getSyncFolderLocation() -> Foundation.URL
  public func getNumberOfDownloadedFiles() -> Swift.Int
  public func getFileInformation(fileID: Foundation.UUID) -> SyncedFileInformationV2?
  @objc deinit
}
extension CloneableFileSyncEngine {
  #if compiler(>=5.3) && $AsyncAwait
  public func getFile(fileID: Swift.String) async throws -> Foundation.Data
  #endif
  public func saveFile(syncRequest: FileSyncRequest, completion: @escaping (Foundation.UUID?) -> Swift.Void) throws
}
public enum FileSyncChangeType {
  case syncActive
  case fileDownloadedForWorkflow(workflowId: Swift.String)
  case fileSyncUpdate(totalfiles: Swift.Int, filesSynced: Swift.Int)
  case syncComplete
  case syncFailed
}
extension CloneableFileSyncEngine {
  public func subscribeToChanges(_ completion: @escaping (FileSyncChangeType) -> Swift.Void) -> FileSyncStatusToken
  public func unsubscribeFromChanges(token: FileSyncStatusToken)
}
@_hasMissingDesignatedInitializers public class SyncStatusToken : Swift.Hashable {
  final public let id: Foundation.UUID
  public func unsubscribe()
  public static func == (lhs: SyncStatusToken, rhs: SyncStatusToken) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DeviceServices {
  public static var locationManager: any CloneableLocationManager.Type
  @objc deinit
}
extension Foundation.Bundle {
  public var isProduction: Swift.Bool {
    get
  }
}
extension Swift.String : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum LogLevel : Swift.String {
  case fatal
  case success
  case debug
  case info
  case warning
  case error
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct LoggerWorkflowInformation : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct LoggerComponentInformation : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CloneableLog {
  public var id: Swift.String
  public var logLevel: LogLevel
  public var message: Swift.String
  public var date: Foundation.Date
  public var user: Cloneable_Swift_Client.UserSchema?
  public var workflow: LoggerWorkflowInformation?
  public var component: LoggerComponentInformation?
  public var displayMode: DisplayMode?
  public var error: (any Swift.Error)?
}
public enum DisplayMode {
  case top
  case middle
  case drawer
  case sheet
  public static func == (a: DisplayMode, b: DisplayMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias LogObserverToken = Foundation.UUID
@_hasMissingDesignatedInitializers public class CloneableLogger {
  public static let shared: CloneableLogger
  public static var logLevel: LogLevel
  public static var logCallback: ((CloneableLog) -> Swift.Void)?
  public static var errorCallback: ((CloneableLog) -> Swift.Void)?
  public static func log(logLevel: LogLevel, message: Swift.String, display: DisplayMode? = nil, component: LoggerComponentInformation? = nil, error: (any Swift.Error)? = nil)
  public static func getLogs() -> [CloneableLog]
  public static func clearLogs()
  public static func notifyObservers(log: CloneableLog)
  public static func subscribe(observer: @escaping (CloneableLog) -> Swift.Void) -> LogObserverToken
  public static func unsubscribe(token: LogObserverToken)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class NetworkMonitor {
  @_hasMissingDesignatedInitializers public class NetworkStatusToken : Swift.Hashable {
    public static func == (lhs: NetworkMonitor.NetworkStatusToken, rhs: NetworkMonitor.NetworkStatusToken) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
extension Cloneable_Swift_Client.CompletedWorkflowSchema {
  public mutating func addObjectRelations(objectInstanceId: Swift.String, objectName: Swift.String)
  public mutating func finalizeWorkflow()
  public mutating func upsertAuditTimeline(timelineObject: Cloneable_Swift_Client.CompletedWorkflowSchemaAuditTimelineInner)
  public mutating func markComponentAsCompleted(dynamicComponentId: Swift.String)
}
extension AnyCodable {
  public var stringValue: Swift.String? {
    get
  }
  public var boolValue: Swift.Bool? {
    get
  }
  public var uuidValue: Foundation.UUID? {
    get
  }
  public var numberValue: Swift.Double? {
    get
  }
  public var dateValue: Foundation.Date? {
    get
  }
}
extension Cloneable_Swift_Client.DeployedWorkflowSchemaObjectsInnerFieldsInnerFileInformation {
  public init(from existing: Cloneable_Swift_Client.DeployedWorkflowSchemaObjectsInnerFieldsInnerFileInformation)
  public func toFieldFileInformation() -> FieldFileInformation
}
extension AnyCloneableData {
  public init?(anyCodable: AnyCodable, type: Swift.String) throws
}
extension AnyCloneableData {
  public var bindingStringValue: Swift.String {
    get
    set
  }
  public var bindingNumberValue: Swift.Double {
    get
    set
  }
  public var bindingDateValue: Foundation.Date {
    get
    set
  }
  public var bindingBooleanValue: Swift.Bool {
    get
    set
  }
  public var bindingStatusValue: Swift.String {
    get
    set
  }
}
public enum CloneableDataError : Swift.Error {
  case invalidValue
  case implementationMissing
  case errorLoadingFromFile
  case errorSavingToFile
  public static func == (a: CloneableDataError, b: CloneableDataError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CloneableDataType {
  var bindingValue: Any { get set }
  func valueType() -> any Any.Type
  func getRawValue() -> Any
  func getTypeAsString() -> Swift.String
  func getStringDescription() -> Swift.String
  func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  func isEqual(to other: any CloneableDataType) -> Swift.Bool
  init(fileURL: Foundation.URL, displayName: Swift.String) throws
  init(json: Swift.String) throws
  func getJSONValue() -> Swift.String
  func saveToFile(fileURL: Foundation.URL) throws
  func getData() -> Foundation.Data?
}
extension CloneableDataType {
  public var complexType: Swift.Bool {
    get
    set
  }
}
extension CloneableDataType {
  public init(fileURL: Foundation.URL, displayName: Swift.String) throws
  public func saveToFile(fileURL: Foundation.URL) throws
  public func getData() -> Foundation.Data?
}
public enum CloneableFileType : Swift.String {
  case all
  case image
  case pdf
  case iosAIModel
  case shapefile
  case kml
  case kmz
  case geotiff
  case raster
  public func getContentType(fileExtension: Swift.String? = nil) -> Swift.String
  public func getFileExtension(contentType: Swift.String? = nil) -> Swift.String
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias CloneableData = AnyCloneableData
public struct AnyCloneableData : Swift.Equatable {
  public var data: any CloneableDataType
  public init(data: any CloneableDataType)
  public static var typeRegistry: [Swift.String : any CloneableDataType.Type]
  public var bindingValue: Any {
    get
    set
  }
  public init(jsonValue: Swift.String, type: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public func isComplex() -> Swift.Bool
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public func isEqual(to: AnyCloneableData) -> Swift.Bool
  public static func == (lhs: AnyCloneableData, rhs: AnyCloneableData) -> Swift.Bool
  public init(fileURL: Foundation.URL, fileType: Swift.String, displayName: Swift.String) throws
  public func saveFile(fileURL: Foundation.URL) throws
  public init?(from jxValue: JXKit.JXValue)
}
extension AnyCloneableData {
  public static func number(_ value: Swift.Double) -> AnyCloneableData
  public static func array(_ value: [AnyCloneableData]) -> AnyCloneableData
  public static func date(_ value: Foundation.Date) -> AnyCloneableData
  public static func status(_ value: Swift.String) -> AnyCloneableData
  public static func string(_ value: Swift.String) -> AnyCloneableData
  public static func uuid(_ value: Foundation.UUID) throws -> AnyCloneableData
  public static func uuid(_ value: Swift.String) throws -> AnyCloneableData
  public static func boolean(_ value: Swift.Bool) -> AnyCloneableData
  public static func boundingbox(_ value: CloneableBoundingBox) -> AnyCloneableData
  public static func object(_ value: Swift.String) -> AnyCloneableData
}
extension AnyCloneableData {
  public func getStringValue() -> Swift.String?
  public func getBoolValue() -> Swift.Bool?
  public func getArrayValue() -> [AnyCloneableData]?
  public func getBoundingBoxValue() -> CloneableBoundingBox?
  public func getDateValue() -> Foundation.Date?
  public func getDepthMap() -> CloneableDepthMap?
  public func getImageDataValue() -> Foundation.Data?
  public func getNumberValue() -> Swift.Double?
  public func getObjectValue() -> Foundation.UUID?
  public func getUUIDValue() -> Foundation.UUID?
  public func getDepthMapValue() -> CloneableDepthMap?
  public func getFileExtension() -> Swift.String?
  public func getObjectFieldValue(fieldName: Swift.String) -> AnyCloneableData?
}
public struct CloneableArray : CloneableDataType {
  public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public init(json: Swift.String, subType: Swift.String) throws
  public init(data: [AnyCloneableData])
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
}
extension AnyCloneableData {
  public func isArray() -> Swift.Bool
  public func getArrayType() -> AnyCloneableData.Type?
  public func getArrayTypeAsString() -> Swift.String?
}
public struct CloneableBoolean : CloneableDataType, Swift.Codable {
  public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public init(_ value: Swift.Bool)
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum TrackState : Swift.Int {
  case new
  case tracked
  case lost
  case removed
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class BoxSnapPoints : ObjectiveC.NSObject, Foundation.NSCopying {
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  public func snapPointsAreEqual(_ object: BoxSnapPoints?) -> Swift.Bool
  public var scaledTop: CoreFoundation.CGPoint?
  public var scaledBottom: CoreFoundation.CGPoint?
  public var scaledLeft: CoreFoundation.CGPoint?
  public var scaledRight: CoreFoundation.CGPoint?
  public var top: CoreFoundation.CGPoint?
  public var bottom: CoreFoundation.CGPoint?
  public var left: CoreFoundation.CGPoint?
  public var right: CoreFoundation.CGPoint?
  public init(top: CoreFoundation.CGPoint? = nil, bottom: CoreFoundation.CGPoint? = nil, left: CoreFoundation.CGPoint? = nil, right: CoreFoundation.CGPoint? = nil, scaledTop: CoreFoundation.CGPoint? = nil, scaledBottom: CoreFoundation.CGPoint? = nil, scaledLeft: CoreFoundation.CGPoint? = nil, scaledRight: CoreFoundation.CGPoint? = nil)
  @objc deinit
}
@objc public class CloneableBoundingBox : ObjectiveC.NSObject, Swift.Codable, CloneableDataType, Foundation.NSCopying {
  required public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public var complexType: Swift.Bool
  @objc public var id: Swift.String
  @objc public var boundingBox: CoreFoundation.CGRect
  @objc public var label: Swift.String
  @objc public var confidence: Swift.Double
  @objc public var trackID: Swift.Double
  @objc public var createdByPerson: Swift.Bool
  @objc public var modifiedByPerson: Swift.Bool
  public var state: TrackState
  public var measuredWidth: Swift.Double?
  public var measuredHeight: Swift.Double?
  public var referenceImageHeight: Swift.Int?
  public var referenceImageWidth: Swift.Int?
  public var measurementSnapped: Swift.Bool?
  public var boxSnapPoints: BoxSnapPoints?
  required public init(from decoder: any Swift.Decoder) throws
  @objc public init(id: Swift.String, boundingBox: CoreFoundation.CGRect, label: Swift.String, confidence: Swift.Double, trackID: Swift.Double, measuredWidth: Foundation.NSNumber? = nil, measuredHeight: Foundation.NSNumber? = nil, state: Swift.Int, createdByPerson: Swift.Bool = false, modifiedByPerson: Swift.Bool = false, referenceImageWidth: Swift.Int, referenceImageHeight: Swift.Int, measurementSnapped: Swift.Bool = false, boxSnapPoints: BoxSnapPoints? = nil)
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public static func isBoundingBoxTouchingEdge(_ boundingBox: CloneableBoundingBox, inImageWithSize imageSize: CoreFoundation.CGSize) -> Swift.Bool
  @objc deinit
}
extension CloneableBoundingBox {
  public func findHorizontalSnapPoints(from depthMap: CloneableDepthMap, threshold: Swift.Float = 0.1, userDefinedBox: CoreFoundation.CGRect? = nil, offset: Swift.Int = 0) -> BoxSnapPoints?
  public func findVerticalSnapPoints(from depthMap: CloneableDepthMap, threshold: Swift.Float = 0.1, userDefinedBox: CoreFoundation.CGRect? = nil, offset: Swift.Int = 0) -> BoxSnapPoints?
  public func updateHorizontalSnapPoints(from depthMap: CloneableDepthMap, threshold: Swift.Float = 0.1) -> CloneableBoundingBox
  public func updateVerticalSnapPoints(from depthMap: CloneableDepthMap, threshold: Swift.Float = 0.1) -> CloneableBoundingBox
  public func findNearestPointInRow(from depthMap: CloneableDepthMap, row: Swift.Int, userDefinedBox: CoreFoundation.CGRect? = nil) -> CoreFoundation.CGPoint?
}
public struct CloneableColor : Swift.Codable, CloneableDataType {
  public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public var r: Swift.Float
  public var g: Swift.Float
  public var b: Swift.Float
  public var a: Swift.Float
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CloneableDate : CloneableDataType, Swift.Codable {
  public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
  public init(date: Foundation.Date)
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DepthMap {
}
public struct CloneableDepthMap : CloneableDataType, Swift.Codable, Swift.Equatable {
  public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public static func == (lhs: CloneableDepthMap, rhs: CloneableDepthMap) -> Swift.Bool
  public var complexType: Swift.Bool
  public var id: Foundation.UUID
  public var depthMap: [[Swift.Float]]
  public var unprojectedDepth: [[[Swift.Float]]]
  public var confidenceMap: [[Swift.Int]]?
  public var refImgSize: (width: Swift.Int, height: Swift.Int)
  public var depthSize: (width: Swift.Int, height: Swift.Int)
  public init(depthMap: [[Swift.Float]], unprojectedDepth: [[[Swift.Float]]], refImgSize: (width: Swift.Int, height: Swift.Int), depthSize: (width: Swift.Int, height: Swift.Int), confidenceMap: [[Swift.Int]]? = nil)
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
}
extension CloneableDepthMap {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func saveToFile(fileURL: Foundation.URL) throws
}
public struct CloneableKML : CloneableDataType {
  public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public var kmlData: Foundation.Data
  public init(kmlData: Foundation.Data)
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func convertKMLToString() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
  public init(fileURL: Foundation.URL, displayName: Swift.String) throws
}
public struct CloneableLocation : CloneableDataType, Swift.Equatable, Swift.Codable {
  public static func == (lhs: CloneableLocation, rhs: CloneableLocation) -> Swift.Bool
  public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public var id: Swift.String
  public var latitude: Swift.Double
  public var longitude: Swift.Double
  public var altitude: Swift.Double?
  public var additional_properties: [Swift.String : CloneableString]?
  public var complexType: Swift.Bool
  public init(id: Swift.String? = nil, latitude: Swift.Double, longitude: Swift.Double, altitude: Swift.Double? = nil, additional_properties: [Swift.String : CloneableString]? = nil)
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func simpleDescription() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct CloneableNumber : CloneableDataType, Swift.Codable {
  public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public init(_ value: Swift.Double)
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CloneableDataObject : CloneableDataType {
  public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public init(data: Swift.String)
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
}
public struct CloneableStatus : CloneableDataType, Swift.Codable {
  public func getJSONValue() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public init(json: Swift.String)
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CloneableString : CloneableDataType, Swift.Codable {
  public func getJSONValue() -> Swift.String
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public init(json: Swift.String)
  public init(_ value: Swift.String)
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CloneableUUID : CloneableDataType {
  public init(json: Swift.String) throws
  public func getJSONValue() -> Swift.String
  public init(uuid: Foundation.UUID)
  public var bindingValue: Any {
    get
    set
  }
  public func valueType() -> any Any.Type
  public func getRawValue() -> Any
  public func getTypeAsString() -> Swift.String
  public func getStringDescription() -> Swift.String
  public func uuidValue() -> Foundation.UUID
  public func getJXValue(context: JXKit.JXContext) -> JXKit.JXValue?
  public func isEqual(to other: any CloneableDataType) -> Swift.Bool
}
extension AnyCloneableData {
  public static func registerDataType(name: Swift.String, type: any CloneableDataType.Type)
  public static func getType(name: Swift.String) -> (any CloneableDataType.Type)?
}
extension Cloneable_Swift_Client.CreateCompletedWorkflowSchema {
  public init(from completedWorkflowSchema: Cloneable_Swift_Client.CompletedWorkflowSchema)
}
extension Cloneable_Swift_Client.UpdateCompletedWorkflowSchema {
  public init(from completedWorkflowSchema: Cloneable_Swift_Client.CompletedWorkflowSchema)
}
extension Cloneable_Swift_Client.UpdateDataObjectFieldsSchema {
  public init(from dataObjectField: Cloneable_Swift_Client.DataObjectSchemaFieldsInner, userId: Swift.String)
}
public protocol SQLiteTable {
}
public enum RUNTIME_ENVIRONMENT {
  case mobile
  case cloud
  public static func == (a: RUNTIME_ENVIRONMENT, b: RUNTIME_ENVIRONMENT) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum APIError : Swift.Error {
  case invalidReturnType
  case couldntAuthenticateRequest
  case apiManagerNotSet
  case serverUnreachable
  case invalidResponse
  public static func == (a: APIError, b: APIError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum AnyCloneableDataError : Swift.Error {
  case failedInit
  case typeNotRegistered(Swift.String)
}
public enum AuthenticationError : Swift.Error {
  case loginError
  case notLoggedIn
  case cannotRefreshUserData
  public static func == (a: AuthenticationError, b: AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CloneableSyncError : Swift.Error {
  case notAuthenticated
  case fileSyncError
  case objectSyncError
  case workflowSyncError
  case completedWorkflowSyncError
  case notificationSyncSerror
  case dataObjectSyncError
  public static func == (a: CloneableSyncError, b: CloneableSyncError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Cloneable_Swift_Client.CreateFileSchema {
  public init(from fileSchema: Cloneable_Swift_Client.FileSchema)
}
extension Cloneable_Swift_Client.FileSchema {
  public init(fileSyncRequest: FileSyncRequest)
}
public enum FileSyncRelation : Swift.String {
  case object
  case workflow
  case component
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct FileSyncRequest {
  public let fileName: Swift.String
  public let data: CloneableData?
  public let fileRelation: FileSyncRelation
  public let fileType: CloneableFileType
  public let one_way_sync: Swift.Bool
  public let user: Swift.String
  public let company: Swift.String
  public let typeRefID: Swift.String?
  public let relatedObjectInstanceID: Foundation.UUID?
  public let relatedWorkflowInstanceID: Foundation.UUID?
  public let relatedDeployedWorkflowIDs: [Swift.String]?
  public let download: Swift.Bool
  public let cloneableFileID: Foundation.UUID?
  public let fieldFileInformation: FieldFileInformation?
  public init(fileName: Swift.String, data: CloneableData?, fileRelation: FileSyncRelation, fileType: CloneableFileType, one_way_sync: Swift.Bool, user: Swift.String, company: Swift.String, typeRefID: Swift.String?, relatedObjectInstanceID: Foundation.UUID?, relatedWorkflowInstanceID: Foundation.UUID?, relatedDeployedWorkflowIDs: [Swift.String]?, download: Swift.Bool, cloneableFileID: Foundation.UUID?, fieldFileInformation: FieldFileInformation?)
}
public struct FieldFileInformation {
  public var fileExtension: Swift.String?
  public var fileName: Swift.String?
  public var fileSize: Swift.Int?
  public var fileType: Swift.String?
  public var fileUrl: Swift.String?
  public var storageAuthProviderName: Swift.String?
  public var storageAuthProviderRefID: Swift.String?
  public var storageProvider: Swift.String?
  public var one_way_sync: Swift.Bool?
  public init(fileExtension: Swift.String?, fileName: Swift.String?, fileSize: Swift.Int?, fileType: Swift.String?, fileUrl: Swift.String?, storageAuthProviderName: Swift.String?, storageAuthProviderRefID: Swift.String?, storageProvider: Swift.String?, one_way_sync: Swift.Bool?)
}
extension Cloneable_Swift_Client.FileSchema {
  public init(decodingFromDB decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct SyncedFileInformationV2 {
  public let id: Foundation.UUID
  public var cloneableFileID: Foundation.UUID?
  public var relatedCloneableObjects: [Foundation.UUID]
  public var relatedCloneableDeployedWorkflows: [Swift.String]
  public var download: Swift.Bool?
  public var syncComplete: Swift.Bool
  public var localFilePath: Swift.String?
  public var fileName: Swift.String
  public init(id: Foundation.UUID, cloneableFileID: Foundation.UUID?, relatedCloneableObjects: [Foundation.UUID], relatedCloneableDeployedWorkflows: [Swift.String], download: Swift.Bool?, syncComplete: Swift.Bool, localFilePath: Swift.String?, fileName: Swift.String)
}
public struct ObjectIdGenerator {
  public static func generate() -> Swift.String
}
public typealias CloneableObserverToken = Foundation.UUID
public enum CloneableConnectionState {
  case connecting
  case connected
  case disconnected
  public static func == (a: CloneableConnectionState, b: CloneableConnectionState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CloneableSyncStatus {
  case not_synced
  case syncing
  case synced
  case sync_error
  public static func == (a: CloneableSyncStatus, b: CloneableSyncStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CloneableAuthStatus {
  case offline
  case not_authenticated
  case auth_error
  case authenticating
  case authenticated
  public static func == (a: CloneableAuthStatus, b: CloneableAuthStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias CloneableObject = Cloneable_Swift_Client.DataObjectSchema
public typealias ObjectField = Cloneable_Swift_Client.DataObjectSchemaFieldsInner
extension Cloneable_Swift_Client.DataObjectSchema : Swift.Identifiable {
  public typealias ID = Swift.String
}
extension Cloneable_Swift_Client.DataObjectSchema {
  public func deepCopy() -> Cloneable_Swift_Client.DataObjectSchema?
}
extension Cloneable_Swift_Client.DataObjectSchemaFieldsInner {
  public mutating func upsertFieldValue(_ value: AnyCloneableData, userId: Swift.String)
}
extension Cloneable_Swift_Client.DataObjectSchema {
  public init(deployedWorkflow: DeployedWorkflow_objects, userId: Swift.String)
}
extension Cloneable_Swift_Client.DataObjectSchemaFieldsInner {
  public init(field: DeployedWorkflow_object_field, userId: Swift.String)
}
public typealias CloneableWorkflow = Cloneable_Swift_Client.CompletedWorkflowSchema
public typealias CloneableWorkflow_auditTimeline = Cloneable_Swift_Client.CompletedWorkflowSchemaAuditTimelineInner
public typealias CloneableWorkflow_relatedObjectTypes = Cloneable_Swift_Client.CompletedWorkflowSchemaRelatedObjectTypesInner
public typealias DeployedWorkflow_components = Cloneable_Swift_Client.DeployedWorkflowSchemaComponentsInner
public typealias DeployedWorkflow_objects = Cloneable_Swift_Client.DeployedWorkflowSchemaObjectsInner
public typealias DeployedWorkflow_object_field = Cloneable_Swift_Client.DeployedWorkflowSchemaObjectsInnerFieldsInner
public struct OutputConnection {
  public var targetInputStaticID: Swift.String
  public var targetDynamicID: Swift.String
  public var targetInput: Swift.String
  public var targetStaticID: Swift.String
  public var targetType: Swift.String
  public init(targetInputStaticID: Swift.String, targetDynamicID: Swift.String, targetInput: Swift.String, targetStaticID: Swift.String, targetType: Swift.String)
}
public typealias NotificationRequest = Cloneable_Swift_Client.NotificationRequestSchema
public typealias NotificationRequest_targetSMSNumbers = Cloneable_Swift_Client.NotificationRequestSchemaTargetSmsNumbersInner
public typealias NotificationRequest_roles_channels = NotificationRequest.TargetCompanyRolesChannels
@_hasMissingDesignatedInitializers public class DataCache {
  @objc deinit
}
public enum ComponentType : Swift.String {
  case ios_workflow_start
  case ios_workflow_end
  case cloud_workflow_start
  case cloud_workflow_end
  case ui
  case processing
  case object
  case logical
  case file_data
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ComponentRuntime : Swift.String {
  case ios
  case cloud
  case web
  case android
  case edge_linux
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol ComponentSubscriber {
  var staticComponentID: Swift.String? { get set }
  var dynamicComponentID: Swift.String? { get set }
  var component: DeployedWorkflow_components? { get set }
  init()
  func frameworkInit(dynamicComponentID: Swift.String, staticComponentID: Swift.String, component: DeployedWorkflow_components)
  func componentWillDeInit(final: Swift.Bool)
  func acceptNewInputs(inputs: [DataInput])
  func navigateButtonTriggeredByFramework()
}
extension ComponentSubscriber {
  public func navigateButtonTriggeredByFramework()
}
public struct Component {
  public var id: Swift.String
  public var type: ComponentType
  public var processingType: (any ComponentSubscriber.Type)?
  public var runtimes: Swift.Array<ComponentRuntime>
  public init(id: Swift.String, type: ComponentType, runtimes: Swift.Array<ComponentRuntime>, processingType: (any ComponentSubscriber.Type)? = nil)
}
public protocol WorkflowService {
  func subscribeComponent(subscriber: any ComponentSubscriber, dynamicComponentID: Swift.String, staticComponentID: Swift.String)
}
public protocol NavigationCoordinator {
  func promptWorkflowEnd()
  func navigate(staticComponentID: Swift.String, dynamicComponentID: Swift.String)
  func endWorkflow()
  func cancelWorkflow()
  func shareNotification(notification: CloneableLog, display: DisplayMode)
  func selectWorkflow(workflowId: Swift.String)
}
extension WorkflowFramework {
  public func recieveNotificationRequest(dynamicComponentID: Swift.String, notificationRequest: NotificationRequest)
  public func sendNotificationRequestsToSyncedRealm()
  #if compiler(>=5.3) && $AsyncAwait
  public func sendNotificationRequestToSyncedRealm(notificationRequest: NotificationRequest) async throws
  #endif
}
public protocol CloneableLocationManager {
  init()
  func getCurrentLocation() throws -> CloneableLocation?
}
public protocol CloneableDataOutput {
  var outputUniqueID: Foundation.UUID { get set }
  var outputCount: Swift.Int { get set }
  var data: AnyCloneableData { get set }
  var outputComponentType: ComponentType { get set }
  var staticComponentID: Swift.String { get set }
  var dynamicComponentID: Swift.String { get set }
  var dynamicOutputID: Swift.String { get set }
  var outputTime: Foundation.Date { get set }
  var targetInput: TargetInput? { get set }
  var batch: Swift.Int? { get set }
}
public protocol CloneableDataInput {
  var inputDynamicID: Swift.String { get set }
  var data: AnyCloneableData { get set }
  var batch: Swift.Int? { get set }
  var creationTime: Foundation.Date { get set }
  var currentBatch: Swift.Bool { get set }
}
public struct DataInput : CloneableDataInput {
  public var componentDynamicID: Swift.String
  public var inputDynamicID: Swift.String
  public var inputStaticID: Swift.String
  public var data: AnyCloneableData
  public var batch: Swift.Int?
  public var creationTime: Foundation.Date
  public var currentBatch: Swift.Bool
  public init(componentDynamicID: Swift.String, inputStaticID: Swift.String, inputDynamicID: Swift.String, data: AnyCloneableData, batch: Swift.Int?, creationTime: Foundation.Date, currentBatch: Swift.Bool)
}
public struct DataOutput : CloneableDataOutput {
  public var outputUniqueID: Foundation.UUID
  public var outputCount: Swift.Int
  public var dynamicOutputID: Swift.String
  public var data: AnyCloneableData
  public var staticComponentID: Swift.String
  public var dynamicComponentID: Swift.String
  public var typeDescription: Swift.String
  public var outputTime: Foundation.Date
  public var outputComponentType: ComponentType
  public var targetInput: TargetInput?
  public var batch: Swift.Int?
  public init(data: AnyCloneableData, staticComponentID: Swift.String, dynamicComponentID: Swift.String, dynamicOutputID: Swift.String, outputComponentType: ComponentType, targetInput: TargetInput? = nil)
  public func convertToDataInput(firstCall: Swift.Bool = false) -> DataInput
}
public struct TargetInput : Swift.Equatable {
  public var componentType: ComponentType
  public var targetInputStaticID: Swift.String
  public var targetInputDynamicID: Swift.String
  public var targetComponentStaticID: Swift.String
  public var targetComponentDynamicID: Swift.String
  public var objectFieldOutputDynamicID: Swift.String?
  public static func == (lhs: TargetInput, rhs: TargetInput) -> Swift.Bool
}
public var workflowFramework: WorkflowFramework?
@_hasMissingDesignatedInitializers public class WorkflowFramework : WorkflowService {
  public var activeUIComponent: Swift.String?
  public var headerHeight: CoreFoundation.CGFloat
  @objc deinit
}
extension WorkflowFramework {
  public func subscribeComponent(subscriber: any ComponentSubscriber, dynamicComponentID: Swift.String, staticComponentID: Swift.String)
  public func getComponent(dynamicID: Swift.String) -> DeployedWorkflow_components
}
extension WorkflowFramework {
  public func getComponentTitle(dynamicComponentID: Swift.String) -> Swift.String
  public func getNextButtonInBarText(dynamicComponentID: Swift.String) -> Swift.String?
  public func navigateButtonTriggeredByFramework(dynamicComponentID: Swift.String)
  public func componentWillPopBack(dynamicComponentID: Swift.String)
  public func endWorkflow()
  public func cancelWorkflow()
}
extension WorkflowFramework {
  public func sendNotification(notification: CloneableLog, display: DisplayMode)
}
extension WorkflowFramework {
  public func getObjectsOfType(objectID: Swift.String, objectTemplateRevision: Swift.Int, searchString: Swift.String = "") -> [CloneableObject]
  public func getLiveObject(instanceID: Foundation.UUID) -> CloneableObject?
}
extension WorkflowFramework {
  public func getObjectByDynamicID(dynamicObjectID: Swift.String) -> DeployedWorkflow_objects?
  public func getFileInformation(fileID: Foundation.UUID) -> SyncedFileInformationV2?
  public func getFileData(fileID: Swift.String, completion: @escaping (Foundation.Data?) -> Swift.Void)
  public func getDataManager() -> DataManager
  public func getUserInformation() -> Cloneable_Swift_Client.UserSchema?
  public func getWorkflowRunID() -> Foundation.UUID
  public func getWorkflowName() -> Swift.String
  public func getDeployedWorkflowID() -> Swift.String
}
extension WorkflowFramework {
  public func sendOutputsToFramework(outputs: [DataOutput])
}
extension ModelToSync : Swift.Equatable {}
extension ModelToSync : Swift.Hashable {}
extension ModelToSync : Swift.RawRepresentable {}
extension APICallStatus : Swift.Equatable {}
extension APICallStatus : Swift.Hashable {}
extension APICallStatus : Swift.RawRepresentable {}
extension FileInformationCallType : Swift.Equatable {}
extension FileInformationCallType : Swift.Hashable {}
extension FileInformationCallType : Swift.RawRepresentable {}
extension CompletedWorkflowCallType : Swift.Equatable {}
extension CompletedWorkflowCallType : Swift.Hashable {}
extension CompletedWorkflowCallType : Swift.RawRepresentable {}
extension NotificationRequestCallType : Swift.Equatable {}
extension NotificationRequestCallType : Swift.Hashable {}
extension NotificationRequestCallType : Swift.RawRepresentable {}
extension DataObjectCallType : Swift.Equatable {}
extension DataObjectCallType : Swift.Hashable {}
extension DataObjectCallType : Swift.RawRepresentable {}
extension LogLevel : Swift.Equatable {}
extension LogLevel : Swift.Hashable {}
extension LogLevel : Swift.RawRepresentable {}
extension DisplayMode : Swift.Equatable {}
extension DisplayMode : Swift.Hashable {}
extension CloneableDataError : Swift.Equatable {}
extension CloneableDataError : Swift.Hashable {}
extension CloneableFileType : Swift.Equatable {}
extension CloneableFileType : Swift.Hashable {}
extension CloneableFileType : Swift.RawRepresentable {}
extension TrackState : Swift.Equatable {}
extension TrackState : Swift.Hashable {}
extension TrackState : Swift.RawRepresentable {}
extension RUNTIME_ENVIRONMENT : Swift.Equatable {}
extension RUNTIME_ENVIRONMENT : Swift.Hashable {}
extension APIError : Swift.Equatable {}
extension APIError : Swift.Hashable {}
extension AuthenticationError : Swift.Equatable {}
extension AuthenticationError : Swift.Hashable {}
extension CloneableSyncError : Swift.Equatable {}
extension CloneableSyncError : Swift.Hashable {}
extension FileSyncRelation : Swift.Equatable {}
extension FileSyncRelation : Swift.Hashable {}
extension FileSyncRelation : Swift.RawRepresentable {}
extension CloneableConnectionState : Swift.Equatable {}
extension CloneableConnectionState : Swift.Hashable {}
extension CloneableSyncStatus : Swift.Equatable {}
extension CloneableSyncStatus : Swift.Hashable {}
extension CloneableAuthStatus : Swift.Equatable {}
extension CloneableAuthStatus : Swift.Hashable {}
extension ComponentType : Swift.Equatable {}
extension ComponentType : Swift.Hashable {}
extension ComponentType : Swift.RawRepresentable {}
extension ComponentRuntime : Swift.Equatable {}
extension ComponentRuntime : Swift.Hashable {}
extension ComponentRuntime : Swift.RawRepresentable {}
